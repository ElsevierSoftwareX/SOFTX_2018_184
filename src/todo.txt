
build a set-based alternative and compare performance ...

consider use of globals, and or bootstrapping the code with some cases with known results  

make round(0.5) match julias behaviour, or better yet implement the different rounding types
       and then precision, which is a whole nother issue

could do an ALT implementation that
   (i) tracks stats of surreals when they are created to avoid
       overhead later 
   (ii) stores a hash value when created, again to avoid overhead
   (iii) creates a Dict of surreals, so we can convert the tree
       structure into a DAG using refs to the Dict, reusing components so that we don't have
       to recompute all of the pieces already computed 

transfinites and ordinals

rewrite README and
   add internal documentation 

3*3

division
	- can we do this natively - currently requires conversion to reals and back    
	- more testing needed

functions	
	better round, more consistent with julia standard round
	       - not trivial because can't just multiply and reuse
	div
	rem
	mod1
	gcd
	lcm

	math functions -- this is hard without cheating by converting to real, and finding canonical equivalent
	     log
	     exp
	     powers
	     trig
         require infinite series, so not valid for finite surreals 

add some automatically generated random tests

"Practically Surreal"

"The Graphical Structure of the Surreal Numbers Examined Through the
 Lens on an Implementation in Julia"

(1) one paper on CodeX, with general stuff on code and algorithms
(2) one recreational maths paper on the structure and nature of surreal arithmetic





