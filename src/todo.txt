floor and round
   make floor(T,x) instead of returntype
   make round(0.5) match julias behaviour, or better yet implement the different rounding types
       and then precision, which is a whole nother issue


size_u = no. of unique surr

could do an ALT implementation that
   (i) tracks stats of surreals when they are created to avoid
       overhead later
   (ii) stores a hash value when created, again to avoid overhead
   (iii) creates a Dict of surreals, so we can convert the tree
       structure into a DAG using refs to the Dict, reusing components so that we don't have
       to recompute all of the pieces already computed 

transfinites and ordinals

add internal documentation 

converting to float64???

test time to see if we cant do some optimisations

3*3

division
	- can we do this natively - currently requires conversion to reals and back    
	- more testing needed
	
functions	
	better round, more consistent with julia standard round
	       - not trivial because can't just multiply and reuse

	trunc

	div
	rem
	mod
	mod1
	gcd
	lcm

	abs2 -- free

	math functions -- this is hard
	     log
	     exp
	     powers
	     trig
	     
add some automatically generated random tests

"Practical Surreals"

"The Graphical Structure of the Surreal Numbers Examined Through the
 Lens on an Implementation in Julia"




